PYTHON:

def pattern_count(text, pattern):
# Search through a string (text) and count the frequency that 
# another string (pattern) occurs.
	frequency = 0
	for x in range(len(text)):
		if text[x: x + len(pattern)] == pattern:
			frequency += 1
	return frequency


def keys_of_max_values(dictionary):
	count = 0
	keys_for_max_values = []
	for key in dictionary.keys():
		if dictionary[key] > count:
			count = dictionary[key]
			del keys_for_max_values[:]
			keys_for_max_values.append(key)
		elif dictionary[key] == count:
			keys_for_max_values.append(key)
	print keys_for_max_values

def which_values_are_t(dictionary, t):
	# Returns a list of keys whose values are at least t.
	keys = []
	for key in dictionary.keys():
		if dictionary[key] >= t:
			keys.append(key)
	print keys


def kmer_frequency(text, k):
# Creates a dictionary of {kmers in text: times they occur in text}
	kmers_counts = {}
	run_count = 0
	most_frequent_vals = []
	for x in range(len(text)-k):
		pattern = text[x:x + k]
		if pattern not in kmers_counts:
			frequency = pattern_count(text, pattern)
			kmers_counts[pattern] = frequency
		else:
			kmers_counts[pattern] += 1
	return kmers_counts


def reverse_complement(nucleotides):
	# Prints the reverse complement of a given string.
	reverse_complement = ""
	for x in nucleotides[::-1]:
		if x == "A":
			reverse_complement += "T"
		elif x == "T":
			reverse_complement += "A"
		elif x == "G":
			reverse_complement += "C"
		elif x == "C":
			reverse_complement += "G"
	print reverse_complement


def formatted_num(messy_solution):
	# Returns just the numbers of a list (no [] or ,). Ex:
	# >>> formatted_num([1, 3, 9])
	# >>> 1 3 9
	if len(messy_solution) == 1:
		print messy_solution[0]
	elif len(messy_solution) > 1:
		print ' '.join(str(x) for x in messy_solution)


def indices_of_pattern(pattern, genome):
	# Prints the indices where pattern occurs in genome, formatted.
	indices = []
	for x in range(len(genome) - len(pattern)):
		if pattern == genome[x:x+len(pattern)]:
			indices.append(x)
	print formatted_num(indices)

def clump_finding(genome, k, t, L):
# In genome, finding k-mers of length k that occur at least t times 
# within a window of length L.
	frequent_kmers = []
	
	# Array of length 4^k, all values initialized to 0.
	# 4^k is the total possible kmers of length k.
	clump = [0] * (4^k) 

	for x in range((4^k) - 1):
		if 


def clump_finding(genome, k, L, t):
	# A list of lists. Each index represents a clump, each value 
	# represents the kmers in that clump seen >= t times.
	# Length will be len(genome) - L?
	kmers_per_clump = []
	for x in range(len(genome) - L):
		clump = genome[x:x + L]
		# Makes a dictionary of {kmer:count}
		kmer_dictionary = kmer_frequency(clump, k)
		#ONLY if kmer occurs >= t times!
		keys_t_values = which_values_are_t(kmer_dictionary, t)
		kmers_per_clump.append(keys_t_values)
	return kmers_per_clump
		
def pop_recurrences(seq):
# not order preserving
	set = {}
	map(set.__setitem__, seq, [])
	return set.keys()
